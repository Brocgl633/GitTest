package IIT_550_hw4;

import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class CentralIndexingServerNode {

    private static final int CLIENT_SOCKET_PORT_1 = 12233;

    private static final int CLIENT_SOCKET_PORT_2 = 12234;

    private static final int CLIENT_SOCKET_PORT_3 = 12235;

    private static final int CLIENT_SOCKET_PORT_4 = 12236;

    private static final int SERVER_SOCKET_PORT_1 = 22233;

    private static final int SERVER_SOCKET_PORT_2 = 22234;

    private static final int SERVER_SOCKET_PORT_3 = 22235;

    private static final int SERVER_SOCKET_PORT_4 = 22236;

    private static final String BACKUP_PATH = "backupfiles/";

    /***
     * key: client number # ip # timestamp
     * value: [the list of file registered at timestamp on client number and ip]
     * eg. {1#192.168.1.11#1708353067375=[graph1.jpg:442, graph2.jpg:1592, sub_files.rar:2354, text1.txt:14, text2.txt:24]}
     */
    private static ConcurrentHashMap<String, ArrayList<String>> spellIpFileMap = new ConcurrentHashMap<>();

    /**
     * key: ip
     * value: [the list of the directories of files stored under this client(ip)]
     * eg. {192.168.1.11=[C:/Users/Administrator/Downloads/iit_550_test_files/]}
     */
    private static ConcurrentHashMap<String, ArrayList<String>> ipDirMap = new ConcurrentHashMap<>();

    /**
     * list of ip of backup's peer node
     */
    private static List<String> backupClientIpList = Collections.synchronizedList(new ArrayList<>());

    /**
     * The peer nodes which are connected to the network.
     */
    private static TreeSet<Integer> onlinePeerNodeSet = new TreeSet<>((o1, o2) -> o1 - o2);

    /**
     * key: registered file name
     * value: [key=part file, value=the peer to which this part file belongs]
     * eg. {t1.txt={C:\Users\Administrator\Downloads\iit_550_test_files\t1.txt_node_1=1},
     *      t2.txt={C:\Users\Administrator\Downloads\iit_550_test_files\t2.txt_node_1=1, C:\Users\Administrator\Downloads\iit_550_test_files\t2.txt_node_2=2}}
     */
    private static Map<String, Map<File, Integer>> fileSplitRegMap = new HashMap<>();

    private static int peerCount = 0;

    public static void main(String[] args) throws Exception {
        System.out.println("****** Central indexing server node is been maintained ******");
        int clientId = 1;

        ServerSocket listener1 = new ServerSocket(CLIENT_SOCKET_PORT_1);
        ServerSocket listener2 = new ServerSocket(CLIENT_SOCKET_PORT_2);
        ServerSocket listener3 = new ServerSocket(CLIENT_SOCKET_PORT_3);
        ServerSocket listener4 = new ServerSocket(CLIENT_SOCKET_PORT_4);
        try {
            while (true) {
                new IpFileInfo(listener1.accept(), clientId++).start();
                new IpFileInfo(listener2.accept(), clientId++).start();
                new IpFileInfo(listener3.accept(), clientId++).start();
                new IpFileInfo(listener4.accept(), clientId++).start();
            }
        } finally {
            listener1.close();
            listener2.close();
            listener3.close();
            listener4.close();
        }
    }

    private static class IpFileInfo extends Thread {
        private Socket socket;

        private int peerNumber;

        public IpFileInfo(Socket socket, int peerNumber) {
            this.socket = socket;
            this.peerNumber = peerNumber;
            logPrint("New connection ---> Peer node id: " + peerNumber + ", ip: " + socket.getInetAddress().getHostAddress());
            peerCount++;
            logPrint("There are " + peerCount + " Peer nodes connected with the server.");
            System.out.println();
        }

        public void run() {
            try {
                ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                out.flush();
                ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
                String clientIp = socket.getInetAddress().getHostAddress();

                Response response = new Response();
                response.setResponseCode(200);
                response.setResponseData("Set Peer node id [ " + peerNumber + " ] as a backup node? (Y/N) : ");
                out.writeObject(response);

                Request clientRequest = (Request) in.readObject();
                String requestType = clientRequest.getRequestType();
                String requestData = (String) clientRequest.getRequestData();
                onlinePeerNodeSet.add(peerNumber);

                if (requestData.equalsIgnoreCase("Y")) {
                    System.out.println("Peer node [ " + peerNumber + " ] set to be a backup node.\n");

                    if (!backupClientIpList.contains(clientIp)) {
                        backupClientIpList.add(clientIp);
                    }

                    if (ipDirMap.containsKey(clientIp)) {
                        ipDirMap.get(clientIp).add(BACKUP_PATH);
                    } else {
                        ArrayList<String> paths = new ArrayList<>();
                        paths.add(BACKUP_PATH);
                        ipDirMap.put(clientIp, paths);
                    }

                    response = new Response();
                    response.setResponseCode(200);
                    response.setResponseData(spellIpFileMap);
                    out.writeObject(response);
                }

                response = new Response();
                response.setResponseCode(200);
                response.setResponseData(ipDirMap.get(clientIp));
                out.writeObject(response);

                while (true) {
                    clientRequest = (Request) in.readObject();
                    requestType = clientRequest.getRequestType();

                    if (requestType.equalsIgnoreCase("REGISTER")) {
                        logPrint("Start registering a file ...");
                        Object[] data = (Object[]) clientRequest.getRequestData();
                        ArrayList<String> registerFileList = (ArrayList<String>) data[0];
                        List<String> regDirPathList = (List<String>) data[1];
                        List<File> fileObjList = (List<File>) data[2];
                        ArrayList<String> fileList = register(clientIp, registerFileList, regDirPathList);
                        registerSplitFile(fileObjList);
                        response = new Response();
                        response.setResponseCode(200);
                        response.setResponseData(fileList);
                        out.writeObject(response);
                    } else if (requestType.equalsIgnoreCase("SEARCH")) {
                        logPrint("Start searching a file ...");
                        String fileName = (String) clientRequest.getRequestData();
                        logPrint("Request from Peer node id [ " + peerNumber + " ] and ip [ " + clientIp + " ] to search file: " + fileName);
                        HashMap<Integer, String> res = search(fileName);
                        if (res.size() > 0) {
                            response = new Response();
                            response.setResponseCode(200);
                            response.setResponseData(res);
                            out.writeObject(response);
                            logPrint("File found.");
                        } else {
                            response = new Response();
                            response.setResponseCode(404);
                            response.setResponseData("File not found.");
                            out.writeObject(response);
                            logPrint("File Not Found.");
                        }
                        System.out.println();
                    } else if (requestType.equalsIgnoreCase("DELETE")) {
                        logPrint("Start deleting a file ...");
                        Object[] data = (Object[]) clientRequest.getRequestData();
                        int clientId = (int) data[0];
                        String ip = (String) data[1];
                        String fileName = (String) data[2];
                        logPrint("Request from Peer node id [ " + clientId + " ] and ip [ " + clientIp + " ] to delete file: " + fileName);
                        int count = delete(clientId, ip, fileName);
                        fileSplitRegMap.remove(fileName);
                        response = new Response();
                        if (count > 0) {
                            response.setResponseCode(200);
                            String result = "[ " + count + " ] files named [ " + fileName + " ] are deleted successfully.";
                            response.setResponseData(result);
                            out.writeObject(response);
                            logPrint(result);
                        } else {
                            response.setResponseCode(404);
                            response.setResponseData("File not found. Delete [ " + fileName + " ] failed.");
                            out.writeObject(response);
                            logPrint("File not found. Delete [ " + fileName + " ] failed.");
                        }
                        System.out.println();
                    } else if (requestType.equalsIgnoreCase("UNREGISTER")) {
                        logPrint("Start unregister a file ...");
                        response = new Response();
                        if (unregister(clientIp)) {
                            response.setResponseCode(200);
                            response.setResponseData("Files in ip [ " + clientIp + " ] have been unregistered.");
                            logPrint("Peer node id [ " + peerNumber + " ], ip [" + clientIp + "] has unregistered all files.");
                        } else {
                            response.setResponseCode(400);
                            response.setResponseData("Error in unregistering files from ip [ " + clientIp + " ].");
                        }
                        out.writeObject(response);
                    } else if (requestType.equalsIgnoreCase("UPDATE_SPLIT_FILE")) {
                        System.out.println("Start transfer the part file information to Server...");
                        String serverIp = (String) clientRequest.getRequestData();
                        updatePartFileInfo(serverIp);
                        System.out.println("Part file nodes information sent.");
                    }  else if (requestType.equalsIgnoreCase("GET_BACKUP_NODES")) {
                        System.out.println("Start getting backup nodes information ...");
                        response = new Response();
                        response.setResponseCode(200);
                        response.setResponseData(backupClientIpList);
                        out.writeObject(response);
                        System.out.println("Backup nodes information sent.");
                    } else if (requestType.equalsIgnoreCase("GET_FILES_LIST")) {
                        logPrint("Start getting files list ...");
                        List<String> allFileInfoList = getAllFileInfo();
                        response = new Response();
                        response.setResponseCode(200);
                        response.setResponseData(allFileInfoList);
                        out.writeObject(response);
                        logPrint("All files information sent.");
                        logPrint(spellIpFileMap.toString());
                        System.out.println();
                    } else if (requestType.equalsIgnoreCase("DISCONNECT")) {
                        logPrint("Start disconnecting to Peer node id [ " + peerNumber + " ] ...");
                        onlinePeerNodeSet.remove(peerNumber);
                        try {
                            socket.close();
                        } catch (IOException e) {
                            logPrint("DISCONNECT error: " + e);
                        }
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            } catch (EOFException e) {
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                logPrint("Error handling client id [ " + peerNumber + " ]: " + e);
                Thread.currentThread().interrupt();
            }
        }

        private void updatePartFileInfo(String serverIp) throws IOException {
            Request request = new Request();
            request.setRequestType("UPDATE_FILE_PART");
            request.setRequestData(fileSplitRegMap);
            ObjectOutputStream out = null;
            Socket socket = null;
            try {
                socket = new Socket(serverIp, SERVER_SOCKET_PORT_1);
                out = new ObjectOutputStream(socket.getOutputStream());
                out.writeObject(request);

                socket = new Socket(serverIp, SERVER_SOCKET_PORT_2);
                out = new ObjectOutputStream(socket.getOutputStream());
                out.writeObject(request);

                socket = new Socket(serverIp, SERVER_SOCKET_PORT_3);
                out = new ObjectOutputStream(socket.getOutputStream());
                out.writeObject(request);

                socket = new Socket(serverIp, SERVER_SOCKET_PORT_4);
                out = new ObjectOutputStream(socket.getOutputStream());
                out.writeObject(request);
                logPrint("fileSplitRegMap : " + fileSplitRegMap);
            } catch (IOException ex) {
                logPrint("Error in send part file information :" + ex);
            } finally {
                if (out != null) {
                    out.close();
                }
                if (socket != null && socket.isConnected()) {
                    socket.close();
                }
            }
        }

        private int delete(int clientId, String ip, String fileName) {
            int count = 0;
            for (Map.Entry<String, ArrayList<String>> entry : spellIpFileMap.entrySet()) {
                String key = entry.getKey();
                String[] split = key.split("#");
                int idKey = Integer.parseInt(split[0].trim());
                String ipKey = split[1];
                if (idKey == clientId && ipKey.equals(ip)) {
                    ArrayList<String> fileInfoList = entry.getValue();
                    int oldSize = fileInfoList.size();
                    fileInfoList.removeIf(x -> x.split(":")[0].equals(fileName));
                    int newSize = fileInfoList.size();
                    count += (oldSize - newSize);
                }
            }
            return count;
        }

        private List<String> getAllFileInfo() {
            List<String> res = new ArrayList<>();
            if (spellIpFileMap.values().size() != 0) {
                for (Map.Entry<String, ArrayList<String>> entry : spellIpFileMap.entrySet()) {
                    String[] split = entry.getKey().split("#");
                    for (String name : entry.getValue()) {
                        String[] info = name.split(":");
                        res.add("Peer node id: " + split[0] + ", ip: " + split[1] + ", file name: " + info[0] + ", file size: " + info[1] + " bytes.");
                    }
                }
            } else {
                res.add("No files on this Peer node.");
            }
            return res;
        }

        public void interrupt() {
            logPrint("Connection in Peer node id [ " + peerNumber + " ] closed.");
            peerCount--;
            logPrint("There are " + peerCount + " Peer nodes connected with the server.");
            if (peerCount == 0) {
                logPrint("There are no Peer nodes connected with the server.");
            }
            System.out.println();
        }

        private void logPrint(String message) {
            LogUtil log = new LogUtil("IndexingServer");
            log.write(message);
            log.close();
            System.out.println(message);
        }

        /**
         * Register the files directory in ip.
         * @param ip 				register ip
         * @param registerFileList  register files list
         * @param regDirPathList    registered files' directory
         * @return list of registered files name
         * @throws IOException
         */
        private ArrayList<String> register(String ip, ArrayList<String> registerFileList, List<String> regDirPathList) throws IOException {
            logPrint("Start registering files from Peer node: " + ip);

            // registerFileList.get(0): registered files' directory
            if (ipDirMap.containsKey(ip)) {
                ipDirMap.get(ip).add(registerFileList.get(0));
            } else {
                ArrayList<String> cur = new ArrayList<>();
                cur.add(registerFileList.get(0));
                ipDirMap.put(ip, cur);
            }
            // only reserve the files name
            registerFileList.remove(0);

            StringBuffer sb = new StringBuffer();
            sb.append(peerNumber).append("#").append(ip).append("#").append(System.currentTimeMillis());
            spellIpFileMap.put(sb.toString(), registerFileList);

            logPrint("" + registerFileList.size() + " files have registered in Peer node [ " + peerNumber + " ] and added into spellIpFileMap.");
            System.out.println();
            ConcurrentHashMap<String, ArrayList<String>> curSpellIpFileMap = new ConcurrentHashMap<>();
            curSpellIpFileMap.put(sb.toString(), registerFileList);
            backupFiles(curSpellIpFileMap, regDirPathList);

            return ipDirMap.get(ip);
        }

        /***
         * Removes the files of the requested client from the spellIpFileMap
         * @param ip    un-register ip
         * @return true: successfully; false: unsuccessfully
         */
        private boolean unregister(String ip) throws IOException {
            int oldSize = spellIpFileMap.size();
            ArrayList<String> deleteFileList = null;

            for (Map.Entry<String, ArrayList<String>> entry: spellIpFileMap.entrySet()) {
                String key = entry.getKey();
                if (key.contains(ip)) {
                    deleteFileList = spellIpFileMap.get(key);
                    spellIpFileMap.remove(key);
                }
            }
            int newSize = spellIpFileMap.size();

            if (newSize < oldSize) {
                Request request = new Request();
                Socket socket = null;
                try {
                    request.setRequestType("REMOVE_FILE");
                    for (String backupIp : backupClientIpList) {
                        socket = new Socket(backupIp, SERVER_SOCKET_PORT_1);
                        ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                        request.setRequestData(deleteFileList);
                        out.writeObject(request);
                        socket = new Socket(backupIp, SERVER_SOCKET_PORT_2);
                        out = new ObjectOutputStream(socket.getOutputStream());
                        request.setRequestData(deleteFileList);
                        out.writeObject(request);
                        socket = new Socket(backupIp, SERVER_SOCKET_PORT_3);
                        out = new ObjectOutputStream(socket.getOutputStream());
                        request.setRequestData(deleteFileList);
                        out.writeObject(request);
                        socket = new Socket(backupIp, SERVER_SOCKET_PORT_4);
                        out = new ObjectOutputStream(socket.getOutputStream());
                        request.setRequestData(deleteFileList);
                        out.writeObject(request);
                        out.close();
                        socket.close();
                    }
                    socket = null;
                } catch (Exception e) {
                    logPrint("Error remove in backup node : " + e);
                } finally {
                    if (socket != null && socket.isConnected()) {
                        socket.close();
                    }
                }
            }

            return (newSize < oldSize);
        }

        /***
         * Search the file in the spellIpFileMap
         * @param fileName    search this file
         * @return Map<client id, client ip>
         */
        private HashMap<Integer, String> search(String fileName) {
            HashMap<Integer, String> res = new HashMap<>();
            for (Map.Entry<String, ArrayList<String>> entry : spellIpFileMap.entrySet()) {
                String key = entry.getKey();
                ArrayList<String> value = entry.getValue();

                for (String fileInfo : value) {
                    if (fileInfo.split(":")[0].equalsIgnoreCase(fileName)) {
                        int clientId = Integer.parseInt(key.split("#")[0].trim());
                        String clientIp = key.split("#")[1].trim();
                        res.put(clientId, clientIp);
                    }
                }
            }
            return res;
        }

        /***
         * Update backup data.
         * @param curSpellIpFileMap file map which are needed backup
         * @param regDirPathList    registered files' directory
         */
        private void backupFiles(ConcurrentHashMap<String, ArrayList<String>> curSpellIpFileMap, List<String> regDirPathList) throws IOException {
            Request request = new Request();
            Socket socket = null;
            try {
                request.setRequestType("UPDATE_BACKUP_DATA");
                for (String node : backupClientIpList) {
                    socket = new Socket(node, SERVER_SOCKET_PORT_1);
                    ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                    Object[] data = new Object[2];
                    data[0] = curSpellIpFileMap;
                    data[1] = regDirPathList;
                    request.setRequestData(data);
                    out.writeObject(request);
                    socket = new Socket(node, SERVER_SOCKET_PORT_2);
                    out = new ObjectOutputStream(socket.getOutputStream());
                    request.setRequestData(data);
                    out.writeObject(request);
                    socket = new Socket(node, SERVER_SOCKET_PORT_3);
                    out = new ObjectOutputStream(socket.getOutputStream());
                    request.setRequestData(data);
                    out.writeObject(request);
                    socket = new Socket(node, SERVER_SOCKET_PORT_4);
                    out = new ObjectOutputStream(socket.getOutputStream());
                    request.setRequestData(data);
                    out.writeObject(request);
                    out.close();
                    socket.close();
                }
                socket = null;
            } catch (Exception ex) {
                logPrint("Error in back up : " + ex);
            } finally {
                if (socket != null && socket.isConnected()) {
                    socket.close();
                }
            }
        }

        private void registerSplitFile(List<File> files) {
            logPrint("register file with splitting : " + files);
            for (File file : files) {
                Map<File, Integer> partFileList = FileUtil.splitFile(file, onlinePeerNodeSet);
                fileSplitRegMap.put(file.getName(), partFileList);
            }
            logPrint("fileSplitRegMap : " + fileSplitRegMap);
        }
    }
}
