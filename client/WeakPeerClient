package com.iit.cao.pa3.client;

import com.iit.cao.pa3.Server.RegistrationCenter;
import com.iit.cao.pa3.Server.ServerThread;
import com.iit.cao.pa3.database.bean.Peer;
import com.iit.cao.pa3.pojo.Constants;
import com.iit.cao.pa3.pojo.UpdateMessage;
import com.iit.cao.pa3.pojo.Message;
import com.iit.cao.pa3.pojo.Response;
import com.iit.cao.pa3.api.WeakPeerService;
import com.iit.cao.pa3.api.SuperPeerService;
import com.iit.cao.pa3.pojo.Node;
import com.iit.cao.pa3.utils.*;

import java.io.*;
import java.util.*;

public class WeakPeerClient extends Thread {

    private static Integer seqNum = 0;

    private static Integer ttr = 5;

    private final String peerName;

    private final String path;

    private final String downloadPath;

    private final List<Node> peerLinkNodeList;

    private final Timer timer = new Timer();

    private Integer modifyTime;

    public WeakPeerClient(String peerName, List<Node> peerLinkNodeList) {
        this.peerName = peerName;
        this.peerLinkNodeList = peerLinkNodeList;
        this.path = "src/dir/" + peerName;
        this.downloadPath = "src/dir/" + peerName + "/download/";
        if (!new File(this.downloadPath).exists()) {
            new File(this.downloadPath).mkdirs();
        }
        this.modifyTime = 0;
        logPrint(peerName + " as a client link into the network ... ", false);
    }

    @Override
    public void run() {
        RegistrationCenter registrationCenter = new RegistrationCenter();
        Stub stub = new Stub(registrationCenter);
        String superName = peerLinkNodeList.get(0).getNodeName();
        logPrint(peerName + "'s super peer is " + superName + " ...", false);
        SuperPeerService superPeerService = (SuperPeerService) stub.getStub(SuperPeerService.class, superName);
        if (superPeerService != null) {
            logPrint(peerName + " got the proxy object from " + superName + " successfully !!!", false);
        }
        Scanner input = new Scanner(System.in);
        timer.schedule(new ScheduleTask(), 0, ttr * 1000);
        long startTime, endTime, time;

        while (true) {
            System.out.println("\n****** Hierarchical peer-to-peer (P2P) system ******");
            System.out.println("Current client is " + peerName);
            System.out.println("1.Register one file from directory [src/dir/].");
            System.out.println("2.Register all files from directory [src/dir/].");
            System.out.println("3.Search one file from the network.");
            System.out.println("4.Download file from the network.");
            System.out.println("5.Get files list from [ " + peerName + " ].");
            System.out.println("6.Deregister one file from the current peer.");
            System.out.println("7.Modify one local file.");
            System.out.println("8.Fresh one file.");
            System.out.println("9.Print super peer log.");
            System.out.println("10.Print weak peer log.");
            System.out.println("11.Print skeleton log.");
            System.out.println("12.Print stub log.");
            System.out.println("13.Exit.");
            System.out.print("Please input number : ");
            int option;

            try {
                option = input.nextInt();
            } catch (NumberFormatException ex) {
                System.out.println("Input is wrong. Please try again.");
                continue;
            }

            switch (option) {
                case 1: {
                    System.out.print("Please input the file name you want to register : ");
                    String fileName = input.next();
                    String filePath = "src/dir/" + fileName;
                    File file = new File(filePath);
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    logPrint("Send register request by file name [ " + fileName + " ] in " + peerName + ".", false);
                    if (file.exists()) {
                        startTime = System.currentTimeMillis();
                        Response response = superPeerService.register(weakPeerId, superName, file);
                        endTime = System.currentTimeMillis();
                        time = endTime - startTime;
                        logPrint(response.getMessage() + " Take " + time + " ms.", true);
                    } else {
                        logPrint("There are no file named [ " + fileName + " ] in path 'src/dir/'.", true);
                    }
                    break;
                }
                case 2: {
                    logPrint("Batch files register request ...", false);
                    List<File> list = FileUtil.getAllFiles(path);
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    startTime = System.currentTimeMillis();
                    Response response = superPeerService.registerAllFiles(weakPeerId, superName, list);
                    endTime = System.currentTimeMillis();
                    time = endTime - startTime;
                    logPrint(response.getMessage() + " Take " + time + " ms.", true);
                    break;
                }
                case 3: {
                    System.out.print("Please input the file name you want to research : ");
                    String fileName = input.next();
                    String messageId = UUID.randomUUID().toString().substring(0, 9);
                    addSequence();
                    messageId += seqNum;
                    Message message = new Message(peerName, fileName, seqNum, messageId, peerLinkNodeList);
                    logPrint("Query file message ===> " + message, false);
                    startTime = System.currentTimeMillis();
                    List<Peer> peers = superPeerService.queryFile(message);
                    endTime = System.currentTimeMillis();
                    time = endTime - startTime;
                    logPrint("Querying file takes " + time + " ms.", true);
                    for (Peer peer : peers) {
                        System.out.println(peer);
                    }
                    break;
                }
                case 4: {
                    System.out.print("Please input the file name you want to download : ");
                    String fileName = input.next();
                    startTime = System.currentTimeMillis();
                    downloadFile(fileName, superPeerService, stub);
                    endTime = System.currentTimeMillis();
                    time = endTime - startTime;
                    logPrint("Downloading file [ " + fileName + " ] takes " + time + " ms.", true);
                    break;
                }
                case 5: {
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    startTime = System.currentTimeMillis();
                    Response response = superPeerService.displayRegisteredFiles(weakPeerId, superName);
                    endTime = System.currentTimeMillis();
                    time = endTime - startTime;
                    List<Peer> registrationFiles = (List<Peer>) response.getData();
                    for (Peer regFile : registrationFiles) {
                        System.out.println("File name [ " + regFile.getFileName() + " ], file size [ " + regFile.getFileSize() + " ] bytes.");
                    }
                    logPrint(response.getMessage() + " Take " + time + " ms.", true);
                    break;
                }
                case 6: {
                    System.out.print("Please input the file you want to unregister: ");
                    String fileName = input.next();
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    startTime = System.currentTimeMillis();
                    Response response = superPeerService.unregisterFile(weakPeerId, fileName, false);
                    endTime = System.currentTimeMillis();
                    time = endTime - startTime;
                    logPrint(response.getMessage() + " takes " + time + " ms.", true);
                    break;
                }
                case 7: {
                    System.out.print("Please input the file you want to modify in '/" + peerName + "/' directory : ");
                    String fileName = input.next();
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    String filePath = "src/dir/" + peerName + "/" + fileName;
                    File file = new File(filePath);
                    if (file.exists()) {
                        if (file.canRead() && file.canWrite()) {

                            startTime = System.currentTimeMillis();

                            try {
                                BufferedWriter writer = new BufferedWriter(new FileWriter(filePath, true));
                                writer.write("Modify this file " + (++modifyTime) + " times.");
                                writer.newLine();
                                writer.close();
                            } catch (IOException ex) {
                                ex.printStackTrace();
                            }

                            // 1. register the new file
                            Response response = superPeerService.register(weakPeerId, superName, file);
                            logPrint(response.getMessage(), true);

                            // 2. deregister the previous file
                            response = superPeerService.unregisterFile(weakPeerId, fileName, true);
                            logPrint(response.getMessage(), true);

                            // 3. broadcast update message to all nodes in the network
                            String messageId = UUID.randomUUID().toString().substring(0, 9);
                            addSequence();
                            messageId += seqNum;
                            UpdateMessage updateMsg = new UpdateMessage(peerName, fileName, seqNum, (Integer) response.getData(), messageId, peerLinkNodeList);
                            System.out.println("The modified file's original version is " + response.getData() + ".");
                            superPeerService.broadcastUpdateMsg(updateMsg);

                            endTime = System.currentTimeMillis();
                            time = endTime - startTime;
                            logPrint("Modifying file [ " + fileName + " ] and broadcast update message take " + time + " ms.", true);
                        } else {
                            logPrint("Modified file is the copy with read-only authorization. Please input again.", true);
                        }
                    } else {
                        logPrint("Modified file does not exit. Please input again.", true);
                    }
                    break;
                }
                case 8: {
                    System.out.print("Please input a file name you want to refresh in '/" + peerName + "/' directory : ");
                    String fileName = input.next();
                    String filePath = "src/dir/" + peerName + "/" + fileName;
                    File file = new File(filePath);
                    if (file.exists()) {
                        System.out.println("Refresh operation hits the file ===> [ " + fileName + " ].");

                        // delete this file(original) in database
                        String[] splits = peerName.split("#V");
                        int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                        startTime = System.currentTimeMillis();
                        Response response = superPeerService.unregisterFile(weakPeerId, fileName, true);
                        System.out.println(response.getMessage());

                        // delete this file(original) in the current WeakPeerId directory
                        if (file.delete()) {
                            downloadFile(fileName, superPeerService, stub);
                        }

                        endTime = System.currentTimeMillis();
                        time = endTime - startTime;
                        logPrint("Refreshing file [ " + fileName + " ] takes " + time + " ms.", true);
                    } else {
                        logPrint("Refreshing file does not exit. Please input again.", true);
                    }
                    break;
                }
                case 9:
                    (new LogUtil("SuperPeer")).print();
                    break;
                case 10:
                    (new LogUtil("WeakPeer")).print();
                    break;
                case 11:
                    (new LogUtil("Skeleton")).print();
                    break;
                case 12:
                    (new LogUtil("Stub")).print();
                    break;
                case 13: {
                    System.out.println("Thanks for using the system.");
                    String[] splits = peerName.split("#V");
                    int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
                    logPrint(peerName + " exits the system ...", false);
                    superPeerService.unregisterPeer(superName, weakPeerId);
                    System.exit(0);
                    input.close();
                    break;
                }
                default: {
                    System.err.println("Input is wrong. Please try again.");
                    break;
                }
            }
        }
    }

    private void downloadFile(String fileName, SuperPeerService superPeerService, Stub stub) {
        String messageId = UUID.randomUUID().toString().substring(0, 9);
        addSequence();
        messageId += seqNum;
        Message message = new Message(peerName, fileName, seqNum, messageId, peerLinkNodeList);
        List<Peer> peerContainFileList = superPeerService.queryFile(message);
        assert peerContainFileList != null;
        int size = peerContainFileList.size();
        if (size <= 0) {
            System.out.println("File name [ " + fileName + " ] is not found. Message does not hit.");
            return;
        }

        Peer masterPeer = null;
        for (Peer peer : peerContainFileList) {
            if (peer.getType().equals("master")) {
                masterPeer = peer;
            }
        }
        System.out.println("File name in this peer ===> " + masterPeer + ".");

        String nodeName = "WeakPeer#V" + masterPeer.getPeerId();
        String ip = (String) YamlUtil.getInstance().getValue(nodeName, "ip");
        Integer port = (Integer) YamlUtil.getInstance().getValue(nodeName, "serverPort");
        ServerThread server = new ServerThread(nodeName, ip, port);
        server.addServer();
        server.start();
        WeakPeerService weakPeerService = (WeakPeerService) stub.getStub(WeakPeerService.class, nodeName);

        Response response = weakPeerService.fetchFileContent(masterPeer);
        String downloadFilePath = downloadPath + fileName;
        if (response.getCode() == Constants.READ_FILE_TO_BUFFER_DATA_SUCCESS) {
            File file = null;
            try {
                file = new File(downloadFilePath);
                if (file.createNewFile()) {
                    System.out.println("Create file [ " + fileName + " ] in local.");
                } else {
                    System.out.println("Can not download from remote peer [ " + masterPeer.getPeerName() + " ].");
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }

            // 将缓冲区的文件下载至本地
            BufferedWriter bw = null;
            try {
                bw = new BufferedWriter(new FileWriter(downloadFilePath));
                bw.write((String) response.getData());
                bw.close();
            } catch (IOException ex) {
                ex.printStackTrace();
            } finally {
                if (bw != null) {
                    try {
                        bw.close();
                    } catch (IOException ex) {
                        ex.printStackTrace();
                    }
                }
            }

            file.setReadOnly();
        }

        File file = new File(downloadFilePath);
        String[] splits = peerName.split("#V");
        int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
        if (file.exists()) {
            Response cur = superPeerService.register(weakPeerId, peerLinkNodeList.get(0).getNodeName(), file);
            System.out.println(cur.getMessage());
        } else {
            System.out.println("Downloaded file does not exit. Please download again.");
        }
    }

    private synchronized void addSequence() {
        seqNum++;
        System.out.println(Thread.currentThread().getName() + " ===> send times : " + seqNum);
    }

    private class ScheduleTask extends TimerTask {
        @Override
        public void run() {
            RegistrationCenter registrationCenter = new RegistrationCenter();
            Stub stub = new Stub(registrationCenter);
            String superPeerName = peerLinkNodeList.get(0).getNodeName();
            SuperPeerService superPeerService = (SuperPeerService) stub.getStub(SuperPeerService.class, superPeerName);

            String[] splits = peerName.split("#V");
            int weakPeerId = Integer.parseInt(splits[splits.length - 1]);
            for (File file : FileUtil.getAllFiles(downloadPath)) {
                if (file == null) {
                    System.out.println("No file ...");
                    break;
                }
                Response res = superPeerService.freshFileVersion(file, weakPeerId);
                ttr = (int) res.getData();
                if (ttr < 0) {
                    System.out.println("Please refresh the file [ " + file.getName() + " ]. You can choose '7' item.");
                }
            }
        }
    }

    private void logPrint(String message, boolean writeConsole) {
        LogUtil log = new LogUtil("WeakPeer");
        log.write(message);
        log.close();
        if (writeConsole) {
            System.out.println(message);
        }
    }

}
