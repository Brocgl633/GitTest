package com.iit.cao.pa3.Server;

import com.iit.cao.pa3.database.bean.Peer;
import com.iit.cao.pa3.database.dao.PeerDao;
import com.iit.cao.pa3.database.Impl.PeerDaoImpl;
import com.iit.cao.pa3.pojo.Constants;
import com.iit.cao.pa3.utils.JdbcUtil;
import com.iit.cao.pa3.api.SuperPeerService;
import com.iit.cao.pa3.pojo.Node;
import com.iit.cao.pa3.pojo.UpdateMessage;
import com.iit.cao.pa3.pojo.Message;
import com.iit.cao.pa3.pojo.Response;
import com.iit.cao.pa3.utils.LogUtil;
import com.iit.cao.pa3.utils.YamlUtil;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.util.*;

public class SuperPeerServiceImpl implements SuperPeerService {

    private static final LogUtil log = new LogUtil("SuperPeer");

    private static final PeerDao dao = new PeerDaoImpl();

    private static final Map<String, Map<String, Message>> nodeNameMsgMap;

    private static final Map<String, Map<String, UpdateMessage>> modifiedFileMsgMap;

    static {
        nodeNameMsgMap = new HashMap<>();
        modifiedFileMsgMap = new HashMap<>();
    }

    private String getFileMd5(String fileName) throws IOException, NoSuchAlgorithmException {
        InputStream is = Files.newInputStream(Paths.get(fileName));
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(Files.readAllBytes(Paths.get(fileName)));
        byte[] digest = md.digest();
        String fileChecksum = Base64.getEncoder().encodeToString(digest);
        return fileChecksum;
    }

    @Override
    public Response register(Integer peerId, String serverName, File file) {
        Connection conn = null;
        try {
            conn = JdbcUtil.getConnection();

            log.write(serverName + " receives the register request ...");
            log.write("Register file ===> " + file);

            String lifeCycle = Constants.LIFE_CYCLE_TYPE_UNEXPIRED;
            String fileType;
            if (file.canRead() && file.canWrite()) {
                fileType = Constants.FILE_TYPE_MASTER;
            } else {
                fileType = Constants.FILE_TYPE_COPY;
            }

            Peer newPeer = new Peer(peerId, serverName, file.getName(), file.getPath());
            Peer originalPeer = dao.getOriginalPeer(conn, newPeer);
            newPeer.setLifeCycle(lifeCycle);
            if (originalPeer == null) {
                if (fileType.equals(Constants.FILE_TYPE_COPY)) {
                    Peer masterPeer = dao.getPeerByFileNameAndType(conn, file.getName(), Constants.FILE_TYPE_MASTER);
                    newPeer.setVersion(masterPeer.getVersion());
                } else {
                    newPeer.setVersion(0);
                }
                newPeer.setFileSize(file.length());
                newPeer.setType(fileType);
                newPeer.setState(Constants.PEER_STATE_VALID);
                dao.insert(conn, newPeer);
                log.write("File [ " + file.getName() + " ] is the first registration ...");
            } else if (originalPeer.getFileSize() != file.length()) {
                Integer versionId = originalPeer.getVersion() + 1;
                newPeer.setVersion(versionId);
                newPeer.setFileSize(file.length());
                newPeer.setType(fileType);
                newPeer.setState(Constants.PEER_STATE_VALID);
                dao.insert(conn, newPeer);
                originalPeer.setState(Constants.PEER_STATE_INVALID);
                dao.update(conn, originalPeer);
                log.write("New file [ " + file.getName() + " ] has registered and updated the original file ...");
            }
            return new Response(200, "File [ " + file.getName() + " ] registered successfully.");
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            JdbcUtil.closeResource(conn, null, null);
        }
        return new Response(401, "File [ " + file.getName() + " ] failed to register.");
    }

    @Override
    public Response registerAllFiles(Integer peerId, String serverName, List<File> lists) {
        Connection conn = null;
        try {
            conn = JdbcUtil.getConnection();

            log.write(serverName + " receives the batch registration request ...");

            String fileType = Constants.FILE_TYPE_COPY;
            String lifeCycle = Constants.LIFE_CYCLE_TYPE_EXPIRED;
            for (File file : lists) {

                log.write("Register file ===> " + file);

                if (file.canRead() && file.canWrite()) {
                    fileType = Constants.FILE_TYPE_MASTER;
                    lifeCycle = Constants.LIFE_CYCLE_TYPE_UNEXPIRED;
                }

                Peer newPeer = new Peer(peerId, serverName, file.getName(), file.getPath());
                Peer originalPeer = dao.getOriginalPeer(conn, newPeer);
                newPeer.setLifeCycle(lifeCycle);
                if (originalPeer == null) {
                    if (fileType.equals(Constants.FILE_TYPE_COPY)) {
                        Peer masterPeer = dao.getPeerByFileNameAndType(conn, file.getName(), Constants.FILE_TYPE_MASTER);
                        newPeer.setVersion(masterPeer.getVersion());
                    } else {
                        newPeer.setVersion(0);
                    }
                    newPeer.setFileSize(file.length());
                    newPeer.setType(fileType);
                    newPeer.setState(Constants.PEER_STATE_VALID);
                    dao.insert(conn, newPeer);
                    log.write("File [ " + file.getName() + " ] is the first registration ...");
                } else if (originalPeer.getFileSize() != file.length()) {
                    Integer versionId = originalPeer.getVersion() + 1;
                    newPeer.setVersion(versionId);
                    newPeer.setFileSize(file.length());
                    newPeer.setType(fileType);
                    newPeer.setState(Constants.PEER_STATE_VALID);
                    originalPeer.setState(Constants.PEER_STATE_INVALID);
                    dao.update(conn, originalPeer);
                    dao.insert(conn, newPeer);
                    log.write("New file [ " + file.getName() + " ] has registered and updated the original file ...");
                }
            }
            return new Response(200, "All files registered successfully.");
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            JdbcUtil.closeResource(conn, null, null);
        }

        return new Response(401, "There are some errors in registration ...");
    }

    @Override
    public Response unregisterFile(Integer peerId, String fileName, Boolean isUpdate) {
        Connection conn = null;
        try {
            conn = JdbcUtil.getConnection();

            log.write("Remote server object receives the unregister request ...");

            List<Peer> lists = dao.getPeerByPeerIdAndFileName(conn, peerId, fileName);
            if (lists.isEmpty()) {
                log.write("File [ " + fileName + "] doesn't exist!");
                return new Response(401, "File [ " + fileName + "] doesn't exist!");
            }

            Integer versionId = null;
            for (Peer peer : lists) {
                if (isUpdate) {
                    if (peer.getState().equals(Constants.PEER_STATE_INVALID)) {
                        versionId = peer.getVersion();
                        dao.deleteById(conn, peer.getId());
                    }
                } else {
                    dao.deleteById(conn, peer.getId());
                }
            }
            log.write("File [ " + fileName + " ] unregistered successfully.");
            return new Response(200, "File [ " + fileName + " ] unregistered successfully.", versionId);
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            JdbcUtil.closeResource(conn, null, null);
        }

        return new Response(401, "There are some errors in deregistration ...");
    }

    private void deleteFileInSameVersion(String serverName, String fileName, Integer version, Integer peerId) {
        Connection conn = null;
        try {
            conn = JdbcUtil.getConnection();
            List<Peer> lists = dao.getPeerListInSameVersion(conn, peerId, serverName, fileName, version);
            if (lists.isEmpty()) {
                log.write("File [ " + fileName + " ] failed to deregister. It doesn't exist!");
                return;
            }

            log.write("Update message with file [ " + fileName + " ] hitting in " + serverName + " !!!");
            for (Peer peer : lists) {
                dao.deleteById(conn, peer.getId());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            JdbcUtil.closeResource(conn, null, null);
        }
    }

    public List<Peer> getPeerContainFile(String serverName, String fileName) {
        Connection conn = null;
        List<Peer> nodeList = null;
        try {
            conn = JdbcUtil.getConnection();
            nodeList = dao.getPeerByFileNameAndSeverName(conn, serverName, fileName);
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            JdbcUtil.closeResource(conn, null, null);
        }
        return nodeList;
    }

    @Override
    public List<Peer> queryFile(Message message) {
        List<Peer> res = new ArrayList<>();
        Queue<Message> queue = new ArrayDeque<>();
        queue.offer(message);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Message msg = queue.poll();
                assert msg != null;
                String nodeName = msg.getNodeName();
                String messageId = msg.getMessageId();
                Integer sequenceNum = msg.getSequenceNum();
                String fileName = msg.getFileName();
                Byte curTtl = msg.getTtl();

                Map<String, Message> curMap = new HashMap<>();
                curMap.put(msg.getMessageId(), msg);

                for (Node neighbor : msg.getLinkNodeList()) {
                    String neighborNodeName = neighbor.getNodeName();
                    if (nodeNameMsgMap.containsKey(neighborNodeName)) {
                        if (nodeNameMsgMap.get(neighborNodeName).containsKey(messageId)) {
                            continue;
                        } else {
                            nodeNameMsgMap.get(neighborNodeName).put(messageId, msg);
                        }
                    } else {
                        nodeNameMsgMap.put(neighborNodeName, curMap);
                    }
                    List<Peer> result = getPeerContainFile(neighborNodeName, fileName);
                    res.addAll(result);

                    // 刷新 ttl
                    if (curTtl != 0) {
                        Message newMsg = new Message(nodeName, fileName, sequenceNum, messageId, null);
                        newMsg.setTtl((byte) (curTtl - 1));
                        Object links = YamlUtil.getInstance().getValue(neighbor.getNodeName(), "linkNodes");
                        List<Node> linkNodeList = YamlUtil.transferMapToObject(links);
                        newMsg.setLinkNodeList(linkNodeList);
                        queue.offer(newMsg);
                    }
                }
            }
        }
        return res;
    }

    @Override
    public void broadcastUpdateMsg(UpdateMessage message) {
        log.write("Remote server object receives the broadcast update file message request ...");
        Queue<UpdateMessage> queue = new ArrayDeque<>();
        queue.add(message);

        log.write("During the update broadcast :");
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                UpdateMessage msg = queue.poll();
                assert msg != null;

                Map<String, UpdateMessage> curMap = new HashMap<>();
                curMap.put(msg.getMessageId(), msg);
                for (Node neighbor : msg.getLinkNodeList()) {
                    String neighborNodeName = neighbor.getNodeName();
                    if (modifiedFileMsgMap.containsKey(neighborNodeName)) {
                        if (modifiedFileMsgMap.get(neighborNodeName).containsKey(msg.getMessageId())) {
                            continue;
                        } else {
                            modifiedFileMsgMap.get(neighborNodeName).put(msg.getMessageId(), msg);
                        }
                    } else {
                        modifiedFileMsgMap.put(neighborNodeName, curMap);
                    }

                    log.write(neighbor + " receives the message ...");

                    String[] splits = neighborNodeName.split("#V");
                    int superPeerId = Integer.parseInt(splits[splits.length - 1]);
                    List<String> WeakNodes = new ArrayList<>();
                    for (int j = 1; j <= 3; j++) {
                        int weakPeerId = (superPeerId - 1) * 3 + j;
                        WeakNodes.add("WeakPeer#V" + weakPeerId);
                    }

                    // delete modified file with the same file name and versionId
                    log.write("Delete modified file with the same file name and versionId.");
                    for (String name : WeakNodes) {
                        String[] curSplit = name.split("#V");
                        Integer weakPeerId = Integer.parseInt(curSplit[curSplit.length - 1]);
                        deleteFileInSameVersion(neighborNodeName, msg.getFileName(), message.getVersion(), weakPeerId);
                    }

                    if (msg.getTtl() != 0) {
                        UpdateMessage newMsg = new UpdateMessage();
                        newMsg.setClientName(msg.getClientName());
                        newMsg.setFileName(msg.getFileName());
                        newMsg.setSequenceNum(msg.getSequenceNum());
                        newMsg.setMessageId(msg.getMessageId());
                        Object links = YamlUtil.getInstance().getValue(neighborNodeName, "linkNodes");
                        List<Node> linkNodeList = YamlUtil.transferMapToObject(links);
                        newMsg.setLinkNodeList(linkNodeList);
                        newMsg.setTtl((byte) (msg.getTtl() - 1));
                        queue.add(newMsg);
                    }

                    // delete modified file in local directory
                    log.write("Delete modified file in local directory.");
                    for (String weakNodeName : WeakNodes) {
                        String path = "src/dir/" + weakNodeName;
                        File file = new File(path);
                        if (!weakNodeName.equals(message.getClientName())) {
                            deleteLocalFile(file, message.getFileName(), weakNodeName);
                        }
                    }
                }
            }
        }

    }

    @Override
    public Response freshFileVersion(File file, Integer peerId) {
        Connection conn = null;
        int invalidCount = 5;
        try {
            conn = JdbcUtil.getConnection();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        List<Peer> peerList = dao.getPeerByPeerIdAndFileName(conn, peerId, file.getName());
        for (Peer peer : peerList) {
            if (peer != null) {
                peer.setLifeCycle(Constants.LIFE_CYCLE_TYPE_EXPIRED);
                dao.update(conn, peer);
                int masterVersion = dao.getPeerByFileNameAndType(conn, file.getName(), Constants.FILE_TYPE_MASTER).getVersion();
                if (peer.getVersion() != masterVersion) {
                    peer.setState(Constants.PEER_STATE_INVALID);
                    dao.update(conn, peer);
                    invalidCount = -1;
                } else {
                    peer.setLifeCycle(Constants.LIFE_CYCLE_TYPE_UNEXPIRED);
                    dao.update(conn, peer);
                }

            }
        }

        return new Response(200, "Fresh copy-files successfully !!!", invalidCount);
    }


    @Override
    public Response unregisterPeer(String serverName, Integer peerId) {
        Connection conn = null;
        try {
            conn = JdbcUtil.getConnection();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        dao.deleteByServerNameAndPeerId(conn, serverName, peerId);

        return new Response(200, "Delete weak peer [ WeakPeer#V" + peerId + " ] successfully !!!");
    }

    private void deleteLocalFile(File file, String fileName, String weakNodeName) {
        if (file.isDirectory()) {
            File[] fileList = file.listFiles();
            for (int i = 0; i < Objects.requireNonNull(fileList).length; i++) {
                deleteLocalFile(fileList[i], fileName, weakNodeName);
            }
        } else {
            if (file.getName().equals(fileName)) {
                log.write("Update message hits the local file [ " + fileName + " ] in " + weakNodeName + " ...");
                file.delete();
            }
        }
    }
}
